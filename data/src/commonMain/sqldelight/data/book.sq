import kotlin.collections.List;
import kotlin.Boolean;
import kotlin.Long;
import kotlin.String;



CREATE TABLE IF NOT EXISTS book(
    _id INTEGER NOT NULL PRIMARY KEY,
    source INTEGER NOT NULL,
    url TEXT NOT NULL,
    artist TEXT,
    author TEXT,
    description TEXT,
    genre TEXT AS List<String>,
    title TEXT NOT NULL,
    status INTEGER NOT NULL,
    thumbnail_url TEXT,
    favorite INTEGER AS Boolean NOT NULL,
    last_update INTEGER AS Long,
    next_update INTEGER AS Long,
    initialized INTEGER AS Boolean NOT NULL,
    viewer INTEGER NOT NULL,
    chapter_flags INTEGER NOT NULL,
    cover_last_modified INTEGER AS Long NOT NULL,
    date_added INTEGER AS Long NOT NULL,
    is_pinned INTEGER AS Boolean NOT NULL DEFAULT 0,
    pinned_order INTEGER NOT NULL DEFAULT 0,
    is_archived INTEGER AS Boolean NOT NULL DEFAULT 0
);


CREATE INDEX IF NOT EXISTS library_favorite_index ON book(favorite) WHERE favorite = 1;
CREATE INDEX IF NOT EXISTS mangas_url_index ON book(url);
-- Performance optimization indexes
CREATE INDEX IF NOT EXISTS idx_book_favorite_id ON book(favorite, _id) WHERE favorite = 1;
CREATE INDEX IF NOT EXISTS idx_book_source_favorite ON book(source, favorite);
-- Unique index to prevent duplicate books with same url and source
CREATE UNIQUE INDEX IF NOT EXISTS idx_book_url_source ON book(url, source);
-- Additional performance indexes for common queries
CREATE INDEX IF NOT EXISTS idx_book_favorite_title ON book(favorite, title) WHERE favorite = 1;
CREATE INDEX IF NOT EXISTS idx_book_favorite_date_added ON book(favorite, date_added DESC) WHERE favorite = 1;
CREATE INDEX IF NOT EXISTS idx_book_favorite_last_update ON book(favorite, last_update DESC) WHERE favorite = 1;
CREATE INDEX IF NOT EXISTS idx_book_pinned ON book(is_pinned, pinned_order) WHERE is_pinned = 1;
CREATE INDEX IF NOT EXISTS idx_book_archived ON book(is_archived) WHERE is_archived = 1;

findAllBooks:
SELECT * FROM book;


findInLibraryBooks:
SELECT  * FROM book WHERE favorite = 1;

findBookById:
SELECT  * FROM book WHERE _id = ?  LIMIT 1;


findBook:
SELECT * FROM book WHERE url = :url AND source = :sourceId  LIMIT 1;

findBookByKey:
SELECT * FROM book WHERE url = :url LIMIT 1;

searchBook:
SELECT * FROM book WHERE title LIKE '%' || :query || '%' AND favorite = 1;

deleteBook:
DELETE FROM book WHERE _id = :bookId;

deleteBookByKey:
DELETE FROM book WHERE url = :url;

deleteAllBook:
DELETE FROM book;

deleteNotInLibraryBook:
DELETE FROM book WHERE favorite = 0;


findFavotiteSourceId:
SELECT source FROM book GROUP BY source ORDER BY COUNT(source) DESC;


-- external

getMangaById:
SELECT *
FROM book
WHERE _id = :id;

getBookByKey:
SELECT * FROM book WHERE url = :key AND source = :sourceId LIMIT 1;

getMangaByUrlAndSource:
SELECT *
FROM book
WHERE url = :url AND source = :source;

getFavorites:
SELECT *
FROM book
WHERE favorite = 1;

getSourceIdWithFavoriteCount:
SELECT
source,
count(*)
FROM book
WHERE favorite = 1
GROUP BY source;

getFavoriteBySourceId:
SELECT *
FROM book
WHERE favorite = 1
AND source = :source;

getDuplicateLibraryManga:
SELECT *
FROM book
WHERE favorite = 1
AND LOWER(title) = :title
AND source = :source
LIMIT 1;

resetViewerFlags:
UPDATE book
SET viewer = 0;

getSourceIdsWithNonLibraryManga:
SELECT source, COUNT(*) AS manga_count
FROM book
WHERE favorite = 0
GROUP BY source;

getLibrary:
SELECT 
    book.*,
    COALESCE(MC.category_id, 0) AS category,
    COALESCE(SUM(CASE WHEN chapter.read = 0 THEN 1 ELSE 0 END), 0) AS unread_count,
    COALESCE(SUM(CASE WHEN chapter.read = 1 THEN 1 ELSE 0 END), 0) AS read_count
FROM book
LEFT JOIN chapter ON book._id = chapter.book_id
LEFT JOIN bookcategories MC ON book._id = MC.book_id
WHERE book.favorite = 1
GROUP BY book._id, MC.category_id
ORDER BY book.title;

getDownloaded:
SELECT book.* FROM book
 JOIN chapter
 ON chapter.book_id = book._id
 WHERE content IS NOT '';





getLastRead:
SELECT M.*, MAX(H.last_read) AS max
FROM book M
LEFT JOIN chapter C
ON M._id = C.book_id
LEFT JOIN history H
ON C._id = H.chapter_id
GROUP BY M._id
HAVING M.favorite = 1
ORDER BY max DESC;

getLatestByLastRead:
SELECT M.*, MAX(H.last_read) AS max
FROM book M
JOIN chapter C
ON M._id = C.book_id
LEFT JOIN history H
ON H.chapter_id = C._id
GROUP BY M._id
HAVING favorite = 1
ORDER BY max DESC ;

getLatestByChapterUploadDate:
SELECT M.*, MAX(C.date_upload) AS max
FROM book M
JOIN chapter C
ON M._id = C.book_id
GROUP BY M._id
HAVING favorite = 1
ORDER BY max DESC;

getLatestByChapterFetchDate:
SELECT M.*, MAX(C.date_fetch) AS max
FROM book M
JOIN chapter C
ON M._id = C.book_id
GROUP BY M._id
HAVING favorite = 1
ORDER BY max DESC;

deleteMangasNotInLibraryBySourceIds:
DELETE FROM book
WHERE favorite = 0 AND source IN :sourceIds;

upsert:
INSERT OR IGNORE INTO book(
_id,source,url,
artist,author,description,
genre,title,status,
thumbnail_url,favorite,
last_update,next_update,initialized,
viewer,chapter_flags,cover_last_modified,
date_added,is_pinned,pinned_order,is_archived)
VALUES (:id,:source,:url,
:artist,:author,:description,
:genre,:title,:status,:thumbnailUrl,
:favorite,:lastUpdate,:nextUpdate,:initialized,
:viewerFlags,:chapterFlags,:coverLastModified,
:dateAdded,:isPinned,:pinnedOrder,:isArchived);


update:
UPDATE book SET
    source = coalesce(:source, source),
    url = coalesce(:url, url),
    author = coalesce(:author, author),
    description = coalesce(:description, description),
    genre = coalesce(:genre, genre),
    title = coalesce(:title, title),
    status = coalesce(:status, status),
    thumbnail_url = coalesce(:thumbnailUrl, thumbnail_url),
    favorite = coalesce(:favorite, favorite),
    last_update = coalesce(:lastUpdate, last_update),
    initialized = coalesce(:initialized, initialized),
    viewer = coalesce(:viewer, viewer),
    chapter_flags = coalesce(:chapterFlags, chapter_flags),
    cover_last_modified = coalesce(:coverLastModified, cover_last_modified),
    date_added = coalesce(:dateAdded, date_added),
    is_pinned = coalesce(:isPinned, is_pinned),
    pinned_order = coalesce(:pinnedOrder, pinned_order),
    is_archived = coalesce(:isArchived, is_archived)
WHERE _id = :id;

deleteByKey:
DELETE FROM book
WHERE url = :key;

deleteNotInLibraryBooks:
DELETE FROM book WHERE book.favorite = 0;

deleteAll:
DELETE FROM book;
deleteByBookId:
DELETE FROM book WHERE book._id = :bookId;

updatePinStatus:
UPDATE book SET
    is_pinned = :isPinned,
    pinned_order = :pinnedOrder
WHERE _id = :bookId;

updatePinnedOrder:
UPDATE book SET
    pinned_order = :pinnedOrder
WHERE _id = :bookId;

updateArchiveStatus:
UPDATE book SET
    is_archived = :isArchived
WHERE _id = :bookId;

selectLastInsertedRowId:
SELECT LAST_INSERT_ROWID();

-- Find all books by key and source (for handling duplicates)
findAllBooksByKeyAndSource:
SELECT * FROM book WHERE url = :key AND source = :sourceId;

-- Delete duplicate books keeping only the one with lowest id
deleteDuplicateBooks:
DELETE FROM book 
WHERE _id NOT IN (
    SELECT MIN(_id) 
    FROM book 
    GROUP BY url, source
);

-- Performance optimized queries for statistics
getCurrentlyReadingCount:
SELECT COUNT(DISTINCT book._id) AS count
FROM book
JOIN chapter ON book._id = chapter.book_id
WHERE book.favorite = 1
GROUP BY book._id
HAVING 
    SUM(CASE WHEN chapter.read = 1 THEN 1 ELSE 0 END) > 0
    AND SUM(CASE WHEN chapter.read = 1 THEN 1 ELSE 0 END) < COUNT(chapter._id);

getFavoriteGenres:
SELECT genre
FROM book
WHERE favorite = 1 AND genre IS NOT NULL;

-- Pagination support for large libraries
getLibraryPaginated:
SELECT 
    book.*,
    COALESCE(MC.category_id, 0) AS category,
    COALESCE(SUM(CASE WHEN chapter.read = 0 THEN 1 ELSE 0 END), 0) AS unread_count,
    COALESCE(SUM(CASE WHEN chapter.read = 1 THEN 1 ELSE 0 END), 0) AS read_count
FROM book
LEFT JOIN chapter ON book._id = chapter.book_id
LEFT JOIN bookcategories MC ON book._id = MC.book_id
WHERE book.favorite = 1
GROUP BY book._id, MC.category_id
ORDER BY book.title
LIMIT :limit OFFSET :offset;

getLibraryCount:
SELECT COUNT(DISTINCT book._id) AS count
FROM book 
WHERE book.favorite = 1;

-- Get books by category with pagination
getLibraryByCategoryPaginated:
SELECT 
    book.*,
    COALESCE(MC.category_id, 0) AS category,
    COALESCE(SUM(CASE WHEN chapter.read = 0 THEN 1 ELSE 0 END), 0) AS unread_count,
    COALESCE(SUM(CASE WHEN chapter.read = 1 THEN 1 ELSE 0 END), 0) AS read_count
FROM book
LEFT JOIN chapter ON book._id = chapter.book_id
LEFT JOIN bookcategories MC ON book._id = MC.book_id
WHERE book.favorite = 1 AND MC.category_id = :categoryId
GROUP BY book._id, MC.category_id
ORDER BY book.title
LIMIT :limit OFFSET :offset;

-- Search with pagination
searchBooksPaginated:
SELECT * FROM book 
WHERE title LIKE '%' || :query || '%' AND favorite = 1
ORDER BY title
LIMIT :limit OFFSET :offset;
